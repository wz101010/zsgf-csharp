// <auto-generated>
/*
 * 用户全部 API 文档
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using ZSGF.Client.Client;
using ZSGF.Client.Model;

namespace ZSGF.Client.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IUserCurrencyApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        UserCurrencyApiEvents Events { get; }

        /// <summary>
        /// 获取用户资产
        /// </summary>
        /// <remarks>
        /// 获取用户的资产列表
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="appKey"></param>
        /// <param name="id"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrenciesApiResponse"/>&gt;</returns>
        Task<IUserCurrenciesApiResponse> UserCurrenciesAsync(string appKey, string id, Option<string> userId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 获取用户资产
        /// </summary>
        /// <remarks>
        /// 获取用户的资产列表
        /// </remarks>
        /// <param name="appKey"></param>
        /// <param name="id"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrenciesApiResponse"/>&gt;</returns>
        Task<IUserCurrenciesApiResponse> UserCurrenciesOrDefaultAsync(string appKey, string id, Option<string> userId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 消费虚拟币
        /// </summary>
        /// <remarks>
        /// 根据提供的参数进行虚拟币消费
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="currencyConsumeRequest">消费请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyConsumeApiResponse"/>&gt;</returns>
        Task<IUserCurrencyConsumeApiResponse> UserCurrencyConsumeAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<CurrencyConsumeRequest> currencyConsumeRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 消费虚拟币
        /// </summary>
        /// <remarks>
        /// 根据提供的参数进行虚拟币消费
        /// </remarks>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="currencyConsumeRequest">消费请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyConsumeApiResponse"/>&gt;</returns>
        Task<IUserCurrencyConsumeApiResponse> UserCurrencyConsumeOrDefaultAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<CurrencyConsumeRequest> currencyConsumeRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 兑换虚拟币
        /// </summary>
        /// <remarks>
        /// 根据提供的参数进行虚拟币兑换
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="exchangeCurrencyRequest">兑换请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyExchangeApiResponse"/>&gt;</returns>
        Task<IUserCurrencyExchangeApiResponse> UserCurrencyExchangeAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 兑换虚拟币
        /// </summary>
        /// <remarks>
        /// 根据提供的参数进行虚拟币兑换
        /// </remarks>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="exchangeCurrencyRequest">兑换请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyExchangeApiResponse"/>&gt;</returns>
        Task<IUserCurrencyExchangeApiResponse> UserCurrencyExchangeOrDefaultAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 充值虚拟币
        /// </summary>
        /// <remarks>
        /// 根据提供的参数进行虚拟币充值
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="rechargePointRequest">充值请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyRechargeApiResponse"/>&gt;</returns>
        Task<IUserCurrencyRechargeApiResponse> UserCurrencyRechargeAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<RechargePointRequest> rechargePointRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 充值虚拟币
        /// </summary>
        /// <remarks>
        /// 根据提供的参数进行虚拟币充值
        /// </remarks>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="rechargePointRequest">充值请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyRechargeApiResponse"/>&gt;</returns>
        Task<IUserCurrencyRechargeApiResponse> UserCurrencyRechargeOrDefaultAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<RechargePointRequest> rechargePointRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 虚拟币交易记录
        /// </summary>
        /// <remarks>
        /// 根据提供的参数获取虚拟币交易记录
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="appKey"></param>
        /// <param name="transType">交易类型 (optional)</param>
        /// <param name="curCode">货币代码 (optional)</param>
        /// <param name="startTime">开始时间 (optional)</param>
        /// <param name="endTime">结束时间 (optional)</param>
        /// <param name="skip">跳过的条数 (optional)</param>
        /// <param name="take">拉取的条数 (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyTransactionsApiResponse"/>&gt;</returns>
        Task<IUserCurrencyTransactionsApiResponse> UserCurrencyTransactionsAsync(string appKey, Option<string> transType = default, Option<string> curCode = default, Option<DateTime> startTime = default, Option<DateTime> endTime = default, Option<int> skip = default, Option<int> take = default, Option<string> userId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 虚拟币交易记录
        /// </summary>
        /// <remarks>
        /// 根据提供的参数获取虚拟币交易记录
        /// </remarks>
        /// <param name="appKey"></param>
        /// <param name="transType">交易类型 (optional)</param>
        /// <param name="curCode">货币代码 (optional)</param>
        /// <param name="startTime">开始时间 (optional)</param>
        /// <param name="endTime">结束时间 (optional)</param>
        /// <param name="skip">跳过的条数 (optional)</param>
        /// <param name="take">拉取的条数 (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyTransactionsApiResponse"/>&gt;</returns>
        Task<IUserCurrencyTransactionsApiResponse> UserCurrencyTransactionsOrDefaultAsync(string appKey, Option<string> transType = default, Option<string> curCode = default, Option<DateTime> startTime = default, Option<DateTime> endTime = default, Option<int> skip = default, Option<int> take = default, Option<string> userId = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IUserCurrenciesApiResponse"/>
    /// </summary>
    public interface IUserCurrenciesApiResponse : ZSGF.Client.Client.IApiResponse, IOk<ZSGF.Client.Model.UserCurrencyListApiResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUserCurrencyConsumeApiResponse"/>
    /// </summary>
    public interface IUserCurrencyConsumeApiResponse : ZSGF.Client.Client.IApiResponse, IOk<ZSGF.Client.Model.BooleanApiResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUserCurrencyExchangeApiResponse"/>
    /// </summary>
    public interface IUserCurrencyExchangeApiResponse : ZSGF.Client.Client.IApiResponse, IOk<ZSGF.Client.Model.BooleanApiResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUserCurrencyRechargeApiResponse"/>
    /// </summary>
    public interface IUserCurrencyRechargeApiResponse : ZSGF.Client.Client.IApiResponse, IOk<ZSGF.Client.Model.BooleanApiResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUserCurrencyTransactionsApiResponse"/>
    /// </summary>
    public interface IUserCurrencyTransactionsApiResponse : ZSGF.Client.Client.IApiResponse, IOk<ZSGF.Client.Model.UserCurrencyCurrencyTransResultApiResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class UserCurrencyApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUserCurrencies;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUserCurrencies;

        internal void ExecuteOnUserCurrencies(UserCurrencyApi.UserCurrenciesApiResponse apiResponse)
        {
            OnUserCurrencies?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUserCurrencies(Exception exception)
        {
            OnErrorUserCurrencies?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUserCurrencyConsume;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUserCurrencyConsume;

        internal void ExecuteOnUserCurrencyConsume(UserCurrencyApi.UserCurrencyConsumeApiResponse apiResponse)
        {
            OnUserCurrencyConsume?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUserCurrencyConsume(Exception exception)
        {
            OnErrorUserCurrencyConsume?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUserCurrencyExchange;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUserCurrencyExchange;

        internal void ExecuteOnUserCurrencyExchange(UserCurrencyApi.UserCurrencyExchangeApiResponse apiResponse)
        {
            OnUserCurrencyExchange?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUserCurrencyExchange(Exception exception)
        {
            OnErrorUserCurrencyExchange?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUserCurrencyRecharge;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUserCurrencyRecharge;

        internal void ExecuteOnUserCurrencyRecharge(UserCurrencyApi.UserCurrencyRechargeApiResponse apiResponse)
        {
            OnUserCurrencyRecharge?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUserCurrencyRecharge(Exception exception)
        {
            OnErrorUserCurrencyRecharge?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUserCurrencyTransactions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUserCurrencyTransactions;

        internal void ExecuteOnUserCurrencyTransactions(UserCurrencyApi.UserCurrencyTransactionsApiResponse apiResponse)
        {
            OnUserCurrencyTransactions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUserCurrencyTransactions(Exception exception)
        {
            OnErrorUserCurrencyTransactions?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class UserCurrencyApi : IUserCurrencyApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<UserCurrencyApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public UserCurrencyApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="UserCurrencyApi"/> class.
        /// </summary>
        /// <returns></returns>
        public UserCurrencyApi(ILogger<UserCurrencyApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, UserCurrencyApiEvents userCurrencyApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<UserCurrencyApi>();
            HttpClient = httpClient;
            Events = userCurrencyApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatUserCurrencies(ref string appKey, ref string id, ref Option<string> userId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="id"></param>
        /// <param name="userId"></param>
        /// <returns></returns>
        private void ValidateUserCurrencies(string appKey, string id, Option<string> userId)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="id"></param>
        /// <param name="userId"></param>
        private void AfterUserCurrenciesDefaultImplementation(IUserCurrenciesApiResponse apiResponseLocalVar, string appKey, string id, Option<string> userId)
        {
            bool suppressDefaultLog = false;
            AfterUserCurrencies(ref suppressDefaultLog, apiResponseLocalVar, appKey, id, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="id"></param>
        /// <param name="userId"></param>
        partial void AfterUserCurrencies(ref bool suppressDefaultLog, IUserCurrenciesApiResponse apiResponseLocalVar, string appKey, string id, Option<string> userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="id"></param>
        /// <param name="userId"></param>
        private void OnErrorUserCurrenciesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string appKey, string id, Option<string> userId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUserCurrencies(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, appKey, id, userId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="id"></param>
        /// <param name="userId"></param>
        partial void OnErrorUserCurrencies(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string appKey, string id, Option<string> userId);

        /// <summary>
        /// 获取用户资产 获取用户的资产列表
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="id"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrenciesApiResponse"/>&gt;</returns>
        public async Task<IUserCurrenciesApiResponse> UserCurrenciesOrDefaultAsync(string appKey, string id, Option<string> userId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UserCurrenciesAsync(appKey, id, userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 获取用户资产 获取用户的资产列表
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="appKey"></param>
        /// <param name="id"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrenciesApiResponse"/>&gt;</returns>
        public async Task<IUserCurrenciesApiResponse> UserCurrenciesAsync(string appKey, string id, Option<string> userId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUserCurrencies(appKey, id, userId);

                FormatUserCurrencies(ref appKey, ref id, ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/UserCurrency/{appKey}/{id}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BappKey%7D", Uri.EscapeDataString(appKey.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["userId"] = ClientUtils.ParameterToString(userId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UserCurrenciesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UserCurrenciesApiResponse>();

                        UserCurrenciesApiResponse apiResponseLocalVar = new UserCurrenciesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/UserCurrency/{appKey}/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUserCurrenciesDefaultImplementation(apiResponseLocalVar, appKey, id, userId);

                        Events.ExecuteOnUserCurrencies(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUserCurrenciesDefaultImplementation(e, "/UserCurrency/{appKey}/{id}", uriBuilderLocalVar.Path, appKey, id, userId);
                Events.ExecuteOnErrorUserCurrencies(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UserCurrenciesApiResponse"/>
        /// </summary>
        public partial class UserCurrenciesApiResponse : ZSGF.Client.Client.ApiResponse, IUserCurrenciesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UserCurrenciesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UserCurrenciesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UserCurrenciesApiResponse(ILogger<UserCurrenciesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public ZSGF.Client.Model.UserCurrencyListApiResponse Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<ZSGF.Client.Model.UserCurrencyListApiResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out ZSGF.Client.Model.UserCurrencyListApiResponse result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUserCurrencyConsume(ref string nonce, ref long timestamp, ref string signature, ref string appKey, ref Option<string> userId, Option<CurrencyConsumeRequest> currencyConsumeRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="nonce"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="currencyConsumeRequest"></param>
        /// <returns></returns>
        private void ValidateUserCurrencyConsume(string nonce, string signature, string appKey, Option<string> userId, Option<CurrencyConsumeRequest> currencyConsumeRequest)
        {
            if (nonce == null)
                throw new ArgumentNullException(nameof(nonce));

            if (signature == null)
                throw new ArgumentNullException(nameof(signature));

            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));

            if (currencyConsumeRequest.IsSet && currencyConsumeRequest.Value == null)
                throw new ArgumentNullException(nameof(currencyConsumeRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="currencyConsumeRequest"></param>
        private void AfterUserCurrencyConsumeDefaultImplementation(IUserCurrencyConsumeApiResponse apiResponseLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<CurrencyConsumeRequest> currencyConsumeRequest)
        {
            bool suppressDefaultLog = false;
            AfterUserCurrencyConsume(ref suppressDefaultLog, apiResponseLocalVar, nonce, timestamp, signature, appKey, userId, currencyConsumeRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="currencyConsumeRequest"></param>
        partial void AfterUserCurrencyConsume(ref bool suppressDefaultLog, IUserCurrencyConsumeApiResponse apiResponseLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<CurrencyConsumeRequest> currencyConsumeRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="currencyConsumeRequest"></param>
        private void OnErrorUserCurrencyConsumeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<CurrencyConsumeRequest> currencyConsumeRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUserCurrencyConsume(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, nonce, timestamp, signature, appKey, userId, currencyConsumeRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="currencyConsumeRequest"></param>
        partial void OnErrorUserCurrencyConsume(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<CurrencyConsumeRequest> currencyConsumeRequest);

        /// <summary>
        /// 消费虚拟币 根据提供的参数进行虚拟币消费
        /// </summary>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="currencyConsumeRequest">消费请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyConsumeApiResponse"/>&gt;</returns>
        public async Task<IUserCurrencyConsumeApiResponse> UserCurrencyConsumeOrDefaultAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<CurrencyConsumeRequest> currencyConsumeRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UserCurrencyConsumeAsync(nonce, timestamp, signature, appKey, userId, currencyConsumeRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 消费虚拟币 根据提供的参数进行虚拟币消费
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="currencyConsumeRequest">消费请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyConsumeApiResponse"/>&gt;</returns>
        public async Task<IUserCurrencyConsumeApiResponse> UserCurrencyConsumeAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<CurrencyConsumeRequest> currencyConsumeRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUserCurrencyConsume(nonce, signature, appKey, userId, currencyConsumeRequest);

                FormatUserCurrencyConsume(ref nonce, ref timestamp, ref signature, ref appKey, ref userId, currencyConsumeRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/UserCurrency/{appKey}/CurrencyConsume";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BappKey%7D", Uri.EscapeDataString(appKey.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["nonce"] = ClientUtils.ParameterToString(nonce);
                    parseQueryStringLocalVar["timestamp"] = ClientUtils.ParameterToString(timestamp);
                    parseQueryStringLocalVar["signature"] = ClientUtils.ParameterToString(signature);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["userId"] = ClientUtils.ParameterToString(userId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (currencyConsumeRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (currencyConsumeRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(currencyConsumeRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UserCurrencyConsumeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UserCurrencyConsumeApiResponse>();

                        UserCurrencyConsumeApiResponse apiResponseLocalVar = new UserCurrencyConsumeApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/UserCurrency/{appKey}/CurrencyConsume", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUserCurrencyConsumeDefaultImplementation(apiResponseLocalVar, nonce, timestamp, signature, appKey, userId, currencyConsumeRequest);

                        Events.ExecuteOnUserCurrencyConsume(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUserCurrencyConsumeDefaultImplementation(e, "/UserCurrency/{appKey}/CurrencyConsume", uriBuilderLocalVar.Path, nonce, timestamp, signature, appKey, userId, currencyConsumeRequest);
                Events.ExecuteOnErrorUserCurrencyConsume(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UserCurrencyConsumeApiResponse"/>
        /// </summary>
        public partial class UserCurrencyConsumeApiResponse : ZSGF.Client.Client.ApiResponse, IUserCurrencyConsumeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UserCurrencyConsumeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UserCurrencyConsumeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UserCurrencyConsumeApiResponse(ILogger<UserCurrencyConsumeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public ZSGF.Client.Model.BooleanApiResponse Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<ZSGF.Client.Model.BooleanApiResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out ZSGF.Client.Model.BooleanApiResponse result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUserCurrencyExchange(ref string nonce, ref long timestamp, ref string signature, ref string appKey, ref Option<string> userId, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="nonce"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="exchangeCurrencyRequest"></param>
        /// <returns></returns>
        private void ValidateUserCurrencyExchange(string nonce, string signature, string appKey, Option<string> userId, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest)
        {
            if (nonce == null)
                throw new ArgumentNullException(nameof(nonce));

            if (signature == null)
                throw new ArgumentNullException(nameof(signature));

            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));

            if (exchangeCurrencyRequest.IsSet && exchangeCurrencyRequest.Value == null)
                throw new ArgumentNullException(nameof(exchangeCurrencyRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="exchangeCurrencyRequest"></param>
        private void AfterUserCurrencyExchangeDefaultImplementation(IUserCurrencyExchangeApiResponse apiResponseLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest)
        {
            bool suppressDefaultLog = false;
            AfterUserCurrencyExchange(ref suppressDefaultLog, apiResponseLocalVar, nonce, timestamp, signature, appKey, userId, exchangeCurrencyRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="exchangeCurrencyRequest"></param>
        partial void AfterUserCurrencyExchange(ref bool suppressDefaultLog, IUserCurrencyExchangeApiResponse apiResponseLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="exchangeCurrencyRequest"></param>
        private void OnErrorUserCurrencyExchangeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUserCurrencyExchange(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, nonce, timestamp, signature, appKey, userId, exchangeCurrencyRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="exchangeCurrencyRequest"></param>
        partial void OnErrorUserCurrencyExchange(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest);

        /// <summary>
        /// 兑换虚拟币 根据提供的参数进行虚拟币兑换
        /// </summary>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="exchangeCurrencyRequest">兑换请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyExchangeApiResponse"/>&gt;</returns>
        public async Task<IUserCurrencyExchangeApiResponse> UserCurrencyExchangeOrDefaultAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UserCurrencyExchangeAsync(nonce, timestamp, signature, appKey, userId, exchangeCurrencyRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 兑换虚拟币 根据提供的参数进行虚拟币兑换
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="exchangeCurrencyRequest">兑换请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyExchangeApiResponse"/>&gt;</returns>
        public async Task<IUserCurrencyExchangeApiResponse> UserCurrencyExchangeAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<ExchangeCurrencyRequest> exchangeCurrencyRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUserCurrencyExchange(nonce, signature, appKey, userId, exchangeCurrencyRequest);

                FormatUserCurrencyExchange(ref nonce, ref timestamp, ref signature, ref appKey, ref userId, exchangeCurrencyRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/UserCurrency/{appKey}/CurrencyExchange";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BappKey%7D", Uri.EscapeDataString(appKey.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["nonce"] = ClientUtils.ParameterToString(nonce);
                    parseQueryStringLocalVar["timestamp"] = ClientUtils.ParameterToString(timestamp);
                    parseQueryStringLocalVar["signature"] = ClientUtils.ParameterToString(signature);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["userId"] = ClientUtils.ParameterToString(userId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (exchangeCurrencyRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (exchangeCurrencyRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(exchangeCurrencyRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UserCurrencyExchangeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UserCurrencyExchangeApiResponse>();

                        UserCurrencyExchangeApiResponse apiResponseLocalVar = new UserCurrencyExchangeApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/UserCurrency/{appKey}/CurrencyExchange", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUserCurrencyExchangeDefaultImplementation(apiResponseLocalVar, nonce, timestamp, signature, appKey, userId, exchangeCurrencyRequest);

                        Events.ExecuteOnUserCurrencyExchange(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUserCurrencyExchangeDefaultImplementation(e, "/UserCurrency/{appKey}/CurrencyExchange", uriBuilderLocalVar.Path, nonce, timestamp, signature, appKey, userId, exchangeCurrencyRequest);
                Events.ExecuteOnErrorUserCurrencyExchange(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UserCurrencyExchangeApiResponse"/>
        /// </summary>
        public partial class UserCurrencyExchangeApiResponse : ZSGF.Client.Client.ApiResponse, IUserCurrencyExchangeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UserCurrencyExchangeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UserCurrencyExchangeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UserCurrencyExchangeApiResponse(ILogger<UserCurrencyExchangeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public ZSGF.Client.Model.BooleanApiResponse Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<ZSGF.Client.Model.BooleanApiResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out ZSGF.Client.Model.BooleanApiResponse result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUserCurrencyRecharge(ref string nonce, ref long timestamp, ref string signature, ref string appKey, ref Option<string> userId, Option<RechargePointRequest> rechargePointRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="nonce"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="rechargePointRequest"></param>
        /// <returns></returns>
        private void ValidateUserCurrencyRecharge(string nonce, string signature, string appKey, Option<string> userId, Option<RechargePointRequest> rechargePointRequest)
        {
            if (nonce == null)
                throw new ArgumentNullException(nameof(nonce));

            if (signature == null)
                throw new ArgumentNullException(nameof(signature));

            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));

            if (rechargePointRequest.IsSet && rechargePointRequest.Value == null)
                throw new ArgumentNullException(nameof(rechargePointRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="rechargePointRequest"></param>
        private void AfterUserCurrencyRechargeDefaultImplementation(IUserCurrencyRechargeApiResponse apiResponseLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<RechargePointRequest> rechargePointRequest)
        {
            bool suppressDefaultLog = false;
            AfterUserCurrencyRecharge(ref suppressDefaultLog, apiResponseLocalVar, nonce, timestamp, signature, appKey, userId, rechargePointRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="rechargePointRequest"></param>
        partial void AfterUserCurrencyRecharge(ref bool suppressDefaultLog, IUserCurrencyRechargeApiResponse apiResponseLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<RechargePointRequest> rechargePointRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="rechargePointRequest"></param>
        private void OnErrorUserCurrencyRechargeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<RechargePointRequest> rechargePointRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUserCurrencyRecharge(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, nonce, timestamp, signature, appKey, userId, rechargePointRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="nonce"></param>
        /// <param name="timestamp"></param>
        /// <param name="signature"></param>
        /// <param name="appKey"></param>
        /// <param name="userId"></param>
        /// <param name="rechargePointRequest"></param>
        partial void OnErrorUserCurrencyRecharge(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string nonce, long timestamp, string signature, string appKey, Option<string> userId, Option<RechargePointRequest> rechargePointRequest);

        /// <summary>
        /// 充值虚拟币 根据提供的参数进行虚拟币充值
        /// </summary>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="rechargePointRequest">充值请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyRechargeApiResponse"/>&gt;</returns>
        public async Task<IUserCurrencyRechargeApiResponse> UserCurrencyRechargeOrDefaultAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<RechargePointRequest> rechargePointRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UserCurrencyRechargeAsync(nonce, timestamp, signature, appKey, userId, rechargePointRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 充值虚拟币 根据提供的参数进行虚拟币充值
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">随机数</param>
        /// <param name="timestamp">时间戳（允许与服务器时间误差在1分钟内）</param>
        /// <param name="signature">签名</param>
        /// <param name="appKey"></param>
        /// <param name="userId"> (optional)</param>
        /// <param name="rechargePointRequest">充值请求参数 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyRechargeApiResponse"/>&gt;</returns>
        public async Task<IUserCurrencyRechargeApiResponse> UserCurrencyRechargeAsync(string nonce, long timestamp, string signature, string appKey, Option<string> userId = default, Option<RechargePointRequest> rechargePointRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUserCurrencyRecharge(nonce, signature, appKey, userId, rechargePointRequest);

                FormatUserCurrencyRecharge(ref nonce, ref timestamp, ref signature, ref appKey, ref userId, rechargePointRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/UserCurrency/{appKey}/CurrencyRecharge";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BappKey%7D", Uri.EscapeDataString(appKey.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["nonce"] = ClientUtils.ParameterToString(nonce);
                    parseQueryStringLocalVar["timestamp"] = ClientUtils.ParameterToString(timestamp);
                    parseQueryStringLocalVar["signature"] = ClientUtils.ParameterToString(signature);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["userId"] = ClientUtils.ParameterToString(userId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (rechargePointRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (rechargePointRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(rechargePointRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UserCurrencyRechargeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UserCurrencyRechargeApiResponse>();

                        UserCurrencyRechargeApiResponse apiResponseLocalVar = new UserCurrencyRechargeApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/UserCurrency/{appKey}/CurrencyRecharge", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUserCurrencyRechargeDefaultImplementation(apiResponseLocalVar, nonce, timestamp, signature, appKey, userId, rechargePointRequest);

                        Events.ExecuteOnUserCurrencyRecharge(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUserCurrencyRechargeDefaultImplementation(e, "/UserCurrency/{appKey}/CurrencyRecharge", uriBuilderLocalVar.Path, nonce, timestamp, signature, appKey, userId, rechargePointRequest);
                Events.ExecuteOnErrorUserCurrencyRecharge(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UserCurrencyRechargeApiResponse"/>
        /// </summary>
        public partial class UserCurrencyRechargeApiResponse : ZSGF.Client.Client.ApiResponse, IUserCurrencyRechargeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UserCurrencyRechargeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UserCurrencyRechargeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UserCurrencyRechargeApiResponse(ILogger<UserCurrencyRechargeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public ZSGF.Client.Model.BooleanApiResponse Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<ZSGF.Client.Model.BooleanApiResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out ZSGF.Client.Model.BooleanApiResponse result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUserCurrencyTransactions(ref string appKey, ref Option<string> transType, ref Option<string> curCode, ref Option<DateTime> startTime, ref Option<DateTime> endTime, ref Option<int> skip, ref Option<int> take, ref Option<string> userId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="transType"></param>
        /// <param name="curCode"></param>
        /// <param name="userId"></param>
        /// <returns></returns>
        private void ValidateUserCurrencyTransactions(string appKey, Option<string> transType, Option<string> curCode, Option<string> userId)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (transType.IsSet && transType.Value == null)
                throw new ArgumentNullException(nameof(transType));

            if (curCode.IsSet && curCode.Value == null)
                throw new ArgumentNullException(nameof(curCode));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="transType"></param>
        /// <param name="curCode"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="skip"></param>
        /// <param name="take"></param>
        /// <param name="userId"></param>
        private void AfterUserCurrencyTransactionsDefaultImplementation(IUserCurrencyTransactionsApiResponse apiResponseLocalVar, string appKey, Option<string> transType, Option<string> curCode, Option<DateTime> startTime, Option<DateTime> endTime, Option<int> skip, Option<int> take, Option<string> userId)
        {
            bool suppressDefaultLog = false;
            AfterUserCurrencyTransactions(ref suppressDefaultLog, apiResponseLocalVar, appKey, transType, curCode, startTime, endTime, skip, take, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="transType"></param>
        /// <param name="curCode"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="skip"></param>
        /// <param name="take"></param>
        /// <param name="userId"></param>
        partial void AfterUserCurrencyTransactions(ref bool suppressDefaultLog, IUserCurrencyTransactionsApiResponse apiResponseLocalVar, string appKey, Option<string> transType, Option<string> curCode, Option<DateTime> startTime, Option<DateTime> endTime, Option<int> skip, Option<int> take, Option<string> userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="transType"></param>
        /// <param name="curCode"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="skip"></param>
        /// <param name="take"></param>
        /// <param name="userId"></param>
        private void OnErrorUserCurrencyTransactionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string appKey, Option<string> transType, Option<string> curCode, Option<DateTime> startTime, Option<DateTime> endTime, Option<int> skip, Option<int> take, Option<string> userId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUserCurrencyTransactions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, appKey, transType, curCode, startTime, endTime, skip, take, userId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="transType"></param>
        /// <param name="curCode"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="skip"></param>
        /// <param name="take"></param>
        /// <param name="userId"></param>
        partial void OnErrorUserCurrencyTransactions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string appKey, Option<string> transType, Option<string> curCode, Option<DateTime> startTime, Option<DateTime> endTime, Option<int> skip, Option<int> take, Option<string> userId);

        /// <summary>
        /// 虚拟币交易记录 根据提供的参数获取虚拟币交易记录
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="transType">交易类型 (optional)</param>
        /// <param name="curCode">货币代码 (optional)</param>
        /// <param name="startTime">开始时间 (optional)</param>
        /// <param name="endTime">结束时间 (optional)</param>
        /// <param name="skip">跳过的条数 (optional)</param>
        /// <param name="take">拉取的条数 (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyTransactionsApiResponse"/>&gt;</returns>
        public async Task<IUserCurrencyTransactionsApiResponse> UserCurrencyTransactionsOrDefaultAsync(string appKey, Option<string> transType = default, Option<string> curCode = default, Option<DateTime> startTime = default, Option<DateTime> endTime = default, Option<int> skip = default, Option<int> take = default, Option<string> userId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UserCurrencyTransactionsAsync(appKey, transType, curCode, startTime, endTime, skip, take, userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 虚拟币交易记录 根据提供的参数获取虚拟币交易记录
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="appKey"></param>
        /// <param name="transType">交易类型 (optional)</param>
        /// <param name="curCode">货币代码 (optional)</param>
        /// <param name="startTime">开始时间 (optional)</param>
        /// <param name="endTime">结束时间 (optional)</param>
        /// <param name="skip">跳过的条数 (optional)</param>
        /// <param name="take">拉取的条数 (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUserCurrencyTransactionsApiResponse"/>&gt;</returns>
        public async Task<IUserCurrencyTransactionsApiResponse> UserCurrencyTransactionsAsync(string appKey, Option<string> transType = default, Option<string> curCode = default, Option<DateTime> startTime = default, Option<DateTime> endTime = default, Option<int> skip = default, Option<int> take = default, Option<string> userId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUserCurrencyTransactions(appKey, transType, curCode, userId);

                FormatUserCurrencyTransactions(ref appKey, ref transType, ref curCode, ref startTime, ref endTime, ref skip, ref take, ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/UserCurrency/{appKey}/CurrencyTransactions";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BappKey%7D", Uri.EscapeDataString(appKey.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (transType.IsSet)
                        parseQueryStringLocalVar["transType"] = ClientUtils.ParameterToString(transType.Value);

                    if (curCode.IsSet)
                        parseQueryStringLocalVar["curCode"] = ClientUtils.ParameterToString(curCode.Value);

                    if (startTime.IsSet)
                        parseQueryStringLocalVar["startTime"] = ClientUtils.ParameterToString(startTime.Value);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["endTime"] = ClientUtils.ParameterToString(endTime.Value);

                    if (skip.IsSet)
                        parseQueryStringLocalVar["skip"] = ClientUtils.ParameterToString(skip.Value);

                    if (take.IsSet)
                        parseQueryStringLocalVar["take"] = ClientUtils.ParameterToString(take.Value);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["userId"] = ClientUtils.ParameterToString(userId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UserCurrencyTransactionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UserCurrencyTransactionsApiResponse>();

                        UserCurrencyTransactionsApiResponse apiResponseLocalVar = new UserCurrencyTransactionsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/UserCurrency/{appKey}/CurrencyTransactions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUserCurrencyTransactionsDefaultImplementation(apiResponseLocalVar, appKey, transType, curCode, startTime, endTime, skip, take, userId);

                        Events.ExecuteOnUserCurrencyTransactions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUserCurrencyTransactionsDefaultImplementation(e, "/UserCurrency/{appKey}/CurrencyTransactions", uriBuilderLocalVar.Path, appKey, transType, curCode, startTime, endTime, skip, take, userId);
                Events.ExecuteOnErrorUserCurrencyTransactions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UserCurrencyTransactionsApiResponse"/>
        /// </summary>
        public partial class UserCurrencyTransactionsApiResponse : ZSGF.Client.Client.ApiResponse, IUserCurrencyTransactionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UserCurrencyTransactionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UserCurrencyTransactionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UserCurrencyTransactionsApiResponse(ILogger<UserCurrencyTransactionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public ZSGF.Client.Model.UserCurrencyCurrencyTransResultApiResponse Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<ZSGF.Client.Model.UserCurrencyCurrencyTransResultApiResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out ZSGF.Client.Model.UserCurrencyCurrencyTransResultApiResponse result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
